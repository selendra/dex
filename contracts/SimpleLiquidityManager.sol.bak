// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IPoolManager} from "./core/interfaces/IPoolManager.sol";
import {PoolKey} from "./core/types/PoolKey.sol";
import {Currency} from "./core/types/Currency.sol";
import {BalanceDelta} from "./core/types/BalanceDelta.sol";
import {ModifyLiquidityParams} from "./core/types/PoolOperation.sol";
import {DeltaResolver} from "./periphery/base/DeltaResolver.sol";
import {ImmutableState} from "./periphery/base/ImmutableState.sol";
import {IERC20Minimal} from "./core/interfaces/external/IERC20Minimal.sol";

/// @title SimpleLiquidityManager - Uses DeltaResolver pattern correctly
contract SimpleLiquidityManager is DeltaResolver {
    constructor(IPoolManager _poolManager) ImmutableState(_poolManager) {}

    /// @notice Add liquidity to a pool
    /// @dev Caller must transfer tokens to this contract before calling
    function addLiquidity(
        PoolKey memory key,
        int24 tickLower,
        int24 tickUpper,
        int256 liquidityDelta
    ) external returns (BalanceDelta delta) {
        delta = abi.decode(
            poolManager.unlock(
                abi.encode(key, tickLower, tickUpper, liquidityDelta)
            ),
            (BalanceDelta)
        );
    }

    /// @notice Unlock callback
    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        require(msg.sender == address(poolManager), "Only pool manager");
        
        (PoolKey memory key, int24 tickLower, int24 tickUpper, int256 liquidityDelta) =
            abi.decode(data, (PoolKey, int24, int24, int256));
        
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: tickLower,
            tickUpper: tickUpper,
            liquidityDelta: liquidityDelta,
            salt: bytes32(0)
        });
        
        // Add liquidity
        (BalanceDelta delta,) = poolManager.modifyLiquidity(key, params, "");
        
        // Settle deltas - tokens come from THIS contract
        int128 amount0 = delta.amount0();
        int128 amount1 = delta.amount1();
        
        if (amount0 > 0) {
            _settle(key.currency0, address(this), uint128(amount0));
        } else if (amount0 < 0) {
            _take(key.currency0, address(this), uint128(-amount0));
        }
        
        if (amount1 > 0) {
            _settle(key.currency1, address(this), uint128(amount1));
        } else if (amount1 < 0) {
            _take(key.currency1, address(this), uint128(-amount1));
        }
        
        return abi.encode(delta);
    }

    /// @notice Pay implementation - CRITICAL: check if payer is this contract
    function _pay(Currency currency, address payer, uint256 amount) internal override {
        address tokenAddr = Currency.unwrap(currency);
        address pmAddr = address(poolManager);
        
        // DEBUG: Revert with the values to see what's being passed
        if (amount > 0) {
            revert(string(abi.encodePacked(
                "DEBUG: token=", toHexString(tokenAddr),
                " pm=", toHexString(pmAddr),
                " payer=", toHexString(payer),
                " amount=", uint2str(amount)
            )));
        }
        
        if (payer == address(this)) {
            // Transfer from this contract
            IERC20Minimal(tokenAddr).transfer(pmAddr, amount);
        } else {
            // Transfer from external payer
            IERC20Minimal(tokenAddr).transferFrom(payer, pmAddr, amount);
        }
    }
    
    function toHexString(address addr) internal pure returns (string memory) {
        bytes memory buffer = new bytes(40);
        for (uint256 i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint160(addr) / (2**(8*(19 - i)))));
            buffer[i*2] = hexChar(uint8(b) / 16);
            buffer[i*2+1] = hexChar(uint8(b) % 16);
        }
        return string(buffer);
    }
    
    function hexChar(uint8 b) internal pure returns (bytes1) {
        if (b < 10) return bytes1(b + 0x30);
        return bytes1(b + 0x57);
    }
    
    function uint2str(uint256 _i) internal pure returns (string memory) {
        if (_i == 0) return "0";
        uint256 j = _i;
        uint256 len;
        while (j != 0) { len++; j /= 10; }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k--;
            uint8 temp = uint8(48 + _i % 10);
            bstr[k] = bytes1(temp);
            _i /= 10;
        }
        return string(bstr);
    }
}
